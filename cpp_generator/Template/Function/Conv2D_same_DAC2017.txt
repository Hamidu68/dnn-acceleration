void DAC2017_{Name}(hls::stream<DATA_T> &I_strm, DATA_T W[$Output_channel][$Input_channel][$Filter_width][$Filter_height], DATA_T B[$Output_channel], hls::stream<DATA_T> &O_strm) {

#pragma HLS INLINE
  int m, x, y, i, j, k;

  DATA_T ifm[$Output_channel], ofm[$Output_channel];
#pragma HLS ARRAY_PARTITION variable=ifm complete dim=0
#pragma HLS ARRAY_PARTITION variable=ofm complete dim=0

  DATA_T I[$Input_channel][4][$Input_height];
  DATA_T O[$Output_channel][2][$Output_height];

#pragma HLS ARRAY_PARTITION variable=I complete dim=1
#pragma HLS ARRAY_PARTITION variable=I complete dim=2
#pragma HLS ARRAY_PARTITION variable=I complete dim=3
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=2
#pragma HLS ARRAY_PARTITION variable=O complete dim=3

 	Conv2D_${num}_x_loop: for (x=0; x<$Input_width+4; x++) {
 		Conv2D_${num}_y_loop: for (y=0; y<$Input_height; y++) {
  		Conv2D_${num}_k_loop: for (k=0; k<$Input_channel; k++) {

   	 		if (x<$Input_width) {
   	 			I[k][x%4][y] = I_strm.read();
   	 		}

  	 			Conv2D_${num}_m_loop: for (m=0; m<$Output_channel; m++) {
#pragma HLS PIPELINE

  	 			if (x>=3 && x < $Input_width+3 ) {
  	 				if(k == 0){
               ofm[m] = B[m];}
            else {
               ofm[m] = O[m][(x-3)%2][y];}

 					if (x-3+0 < $Input_width && y+0 < $Input_height) {
 						ifm[m] = I[k][(x-3+0)%4][y+0];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][0][0];

 					if (x-3+0 < $Input_width && y+1 < $Input_height) {
 						ifm[m] = I[k][(x-3+0)%4][y+1];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][0][1];

 					if (x-3+0 < $Input_width && y+2 < $Input_height) {
						ifm[m] = I[k][(x-3+0)%4][y+2];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][0][2];

 					if (x-3+1 < $Input_width && y+0 < $Input_height) {
 						ifm[m] = I[k][(x-3+1)%4][y+0];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][1][0];

 					if (x-3+1 < $Input_width && y+1 < $Input_height) {
 						ifm[m] = I[k][(x-3+1)%4][y+1];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][1][1];

 					if (x-3+1 < $Input_width && y+2 < $Input_height) {
 						ifm[m] = I[k][(x-3+1)%4][y+2];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][1][2];

 					if (x-3+2 < $Input_width && y+0 < $Input_height) {
 						ifm[m] = I[k][(x-3+2)%4][y+0];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][2][0];

 					if (x-3+2 < $Input_width && y+1 < $Input_height) {
 						ifm[m] = I[k][(x-3+2)%4][y+1];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][2][1];

 					if (x-3+2 < $Input_width && y+2 < $Input_height) {
 						ifm[m] = I[k][(x-3+2)%4][y+2];
 					} else {
 						ifm[m] = 0; // zero padding
 					}
 					ofm[m] = ofm[m] + ifm[m] * W[m][k][2][2];

          O[m][(x-3)%2][y] = ofm[m];

	 				}
  	 			if (k==$Input_channel-1) {
             if(x>=4) {
  	 			 			O_strm.write(O[m][(x-4)%2][y]);
  	 			  	}
  	 			}
 	 			}

 		}
   		}
 	}
}
